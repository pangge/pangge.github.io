<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[goldencui]]></title>
  <subtitle><![CDATA[get a real life]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://goldencui.org/"/>
  <updated>2014-10-29T02:17:57.976Z</updated>
  <id>http://goldencui.org/</id>
  
  <author>
    <name><![CDATA[goldencwcui]]></name>
    <email><![CDATA[goldencwcui@hotmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[网络资源搜索爬虫(python 3.4.1实现)]]></title>
    <link href="http://goldencui.org/2014/10/15/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E6%90%9C%E7%B4%A2%E7%88%AC%E8%99%AB(python%203.4.1%E5%AE%9E%E7%8E%B0)/"/>
    <id>http://goldencui.org/2014/10/15/网络资源搜索爬虫(python 3.4.1实现)/</id>
    <published>2014-10-15T02:16:50.000Z</published>
    <updated>2014-10-15T08:24:18.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://abstrusegoose.com/strips/how_stuff_works.png" alt="" title="silly man"><br>最近在学习python语言，python以前没有接触，只用过perl，以前使用perl做一些大的数据集处理，当时也是比较生疏，所以一上来看了简单的官方说明文档，就马上开始coding，大约一周基本就对perl的特性比较熟悉了。所以这次我秉持着从实践中学习技术的角度，打算用python做一些小程序，顺便熟悉python语言的各个方面的特性，也因为我对网络爬虫一直都很有些兴趣，就打算着手做个小工具。<br><a id="more"></a><br>使用python做网络爬虫，网上的资源很多，我搞不清为什么很多人和机构都热衷于用python做网络爬虫，大概是因为python在这方面提供的支持库比较多也比较容易实现吧。现有的比较典型的开源爬虫架构如<a href="http://scrapy.org/" target="_blank" rel="external">scrapy</a>（python实现），其实现的功能已经比较全面了，最早的时候想了解网络爬虫的原理的时候，曾经尝试过使用scrapy定制，scrapy已经实现了比较复杂的爬虫功能，官方文档也介绍的很详细。不过为了满足我重复造轮子的好奇心，决定自己做一下,多给脑子里填一些东西</p>
<p>python实现网络爬虫的原理和架构网上资源很多，我就不在这里赘述，大家可以参考这些个链接了解：<br>1.<a href="http://www.zhihu.com/question/20899988" target="_blank" rel="external">如何入门网络爬虫?</a><br>2.<a href="http://www.zhihu.com/question/21358581" target="_blank" rel="external">你是如何开始能写python爬虫？</a></p>
<p>用python 3做网络爬虫可以使用基本的http库也可以使用urllib（注意在python2.7.*以前都是urllib2，更新后urllib2被丢弃）这种库提供对网页url的处理模块。网上充斥着大量的爬虫教程绝大多数部分描述的是使用python2 +urllib2库。使用python3做爬虫还比较少，基本原理是一样的，不过就是urlib库里一些功能的实现和老版本的库稍有不同。<br>简单的使用urllib抓取网页的例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line">f = urllib.request.urlopen(<span class="string">'http://www.python.org/'</span>)</div><div class="line">print(f.read().decode(<span class="string">'urf-8'</span>))</div></pre></td></tr></table></figure>

<p>urllib的具体使用接口和方法参加<a href="https://docs.python.org/3/library/urllib.request.html#module-urllib.request" target="_blank" rel="external">官方文档</a>，这里不再详述。<br>对于网络爬虫最很重要的一环，网页页面HTML的处理方法，python官方给出了一些标准库，不过有一个第三方库<a href="http://beautifulsoup.readthedocs.org/en/latest/" target="_blank" rel="external">beautiful soup</a>对抓取的网页分析更加方便，本文所述的程序采用这个库做HTML页面分析和处理。<br>爬虫关键的就是性能问题，影响性能的原因一个是因为爬虫程序搜索网页的逻辑本身耗时，另一个是抓取页面响应时的耗时，前一种耗时可以采用python标准库中的多线程对爬虫程序进行优化，提取主页中的关键URL采用多个爬虫线程进行爬取。针对后一种耗时，可以采用集群的方式对爬虫进行优化，不过本文研究的程序仅仅作为一种学习，不深入讨论。这里指给出优化的一小部分，python多线程的实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading, zipfile</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncZip</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, infile, outfile)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.infile = infile</div><div class="line">        self.outfile = outfile</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        f = zipfile.ZipFile(self.outfile, <span class="string">'w'</span>, zipfile.ZIP_DEFLATED)</div><div class="line">        f.write(self.infile)</div><div class="line">        f.close()</div><div class="line">        print(<span class="string">'Finished background zip of:'</span>, self.infile)</div><div class="line"></div><div class="line">background = AsyncZip(<span class="string">'mydata.txt'</span>, <span class="string">'myarchive.zip'</span>)</div><div class="line">background.start()</div><div class="line">print(<span class="string">'The main program continues to run in foreground.'</span>)</div><div class="line"></div><div class="line">background.join()    <span class="comment"># Wait for the background task to finish</span></div><div class="line">print(<span class="string">'Main program waited until background was done.'</span>)</div></pre></td></tr></table></figure>

<p>本文描述的爬虫主要功能是在给定的某个主页下进行广度搜索，找到子页面和父页面中包含的所有pdf和doc/docx文档并下载。之所以做这样的一个工具是因为最近在看一些论文，经常一些学术性网站会放出论文的pdf版本，不过由于pdf文件在网页中分布比较分散，手工下载起来比较麻烦，因此尝试自动爬取网页中的这些资源，然后再逐个检索。<br>爬虫的GUI框架使用<a href="http://www.tkdocs.com/tutorial/index.html" target="_blank" rel="external">Tkinter</a>，Tkinter支持很多语言，比如ruby，perl，python等，是一个比较简单图形界面库，之所以不采用其他第三方GUI框架是因为这些框架很多只支持python2.7.*以前的版本，而我这里用的python3.4.1，无奈选择了最方便的方法。<br>下面是程序的界面：<br><img src="/imgs/爬虫主界面.PNG" alt="主界面" title="主界面"><br><img src="/imgs/爬虫搜索时.PNG" alt="运行时" title="运行时"><br>下载文件的存储路径在设置按钮内设置，界面真心丑，不过能用…</p>
<p><strong>程序的源码在<a href="https://github.com/pangge/python-crawler-ccw" target="_blank" rel="external">我的github</a>上，欢迎大家交流学习。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://abstrusegoose.com/strips/how_stuff_works.png" alt="" title="silly man"><br>最近在学习python语言，python以前没有接触，只用过perl，以前使用perl做一些大的数据集处理，当时也是比较生疏，所以一上来看了简单的官方说明文档，就马上开始coding，大约一周基本就对perl的特性比较熟悉了。所以这次我秉持着从实践中学习技术的角度，打算用python做一些小程序，顺便熟悉python语言的各个方面的特性，也因为我对网络爬虫一直都很有些兴趣，就打算着手做个小工具。<br>]]>
    
    </summary>
    
      <category term="pthon3.4.1" scheme="http://goldencui.org/tags/pthon341/"/>
    
      <category term="网络爬虫" scheme="http://goldencui.org/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
      <category term="python多线程" scheme="http://goldencui.org/tags/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="python" scheme="http://goldencui.org/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[windows64位环境下python安装numpy、scipy和matplotlib]]></title>
    <link href="http://goldencui.org/2014/10/02/windows64%E4%BD%8D%E7%8E%AF%E5%A2%83%E4%B8%8Bpython%E5%AE%89%E8%A3%85numpy%E3%80%81scipy%E5%92%8Cmatplotlib/"/>
    <id>http://goldencui.org/2014/10/02/windows64位环境下python安装numpy、scipy和matplotlib/</id>
    <published>2014-10-02T08:47:04.000Z</published>
    <updated>2014-10-15T06:52:06.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>最近想使用python做一些机器学习方向的算法实现，使用python做数据分析和矩阵运算什么的常需要三个库文件：numpy、scipy和matplotlib，于是着手安装。<br>我自己机子的配置是win8+64位操作系统，python安装的版本是3.4.1。安装这几个库首先安装numpy，然后是scipy和matplotlib。<br>查询了numpy的官网后发现根本没有64位，3.4版本python的release版本包，可能是python3.4刚更新的缘故，SourceForge的更新比较慢，还没有最新的发布。scipy和matplotlib也相同，也真是痛苦。<br>上网搜了一些解决方案，当时以为比较简单的问题，直接baidu，结果真是失望，搜索出来的都是无关紧要的内容（原谅我没有google…）。<br>终于在stackoverflow里查到了一些方案，其中一个<a href="http://stackoverflow.com/questions/11200137/installing-numpy-on-64bit-windows-7-with-python-2-7-3" target="_blank" rel="external">install numpy on 64bit win7 with python2.7.3</a>，里面提示了一个<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy" target="_blank" rel="external">资源网站</a>，网站里发布了根据<a href="https://software.intel.com/en-us/intel-mkl" target="_blank" rel="external">Intel® Math Kernel Library</a>第三方生成的最新的python库，进去看了一下，里面很多python可使用的编译好的库。<br>由于我自己python版本是3.4.1，于是选择了这几个文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">numpy-MKL-<span class="number">1.9</span>.<span class="number">0</span>.win-amd64-<span class="keyword">py3</span>.<span class="number">4</span>.<span class="keyword">exe</span></div><div class="line">SciPy-<span class="number">0.13</span>.<span class="number">2</span>.win-AMD64-<span class="keyword">py3</span>.<span class="number">4</span>.<span class="keyword">exe</span></div><div class="line">matplotlib-<span class="number">1.4</span>.<span class="number">0</span>.win-amd64-<span class="keyword">py3</span>.<span class="number">4</span>.<span class="keyword">exe</span></div></pre></td></tr></table></figure>

<p><a id="more"></a>安装numpy的时候一路点进去，安装快要结束的时候出现安装程序崩溃的问题。当时吓了一跳，以为是安装程序不匹配，没办法自己搞虚拟机准备用linux环境下的解决方案。后面无意间在windows下测试了一下numpy是否安装成功<br>结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;<span class="keyword">from</span> numpy <span class="keyword">import</span> <span class="keyword">import</span> *</div><div class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line">&gt;&gt;&gt;mat(a)</div><div class="line">&gt;&gt;&gt;matrix([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</div></pre></td></tr></table></figure>

<p>艾玛!!!  竟然没有问题，证明numpy安装应该没有错,可以使用，scipy和mat的安装也出现类似问题，不过暂时都不影响使用，不知道后续会不会出问题。之所以程序安装会出现崩溃，我怀疑应该我自己win8系统的错误或者库的兼容性问题。后面还没有完整测试这几个库，不知道是不是其它电脑也会出现类似问题，唉也毕竟是第三方的库，多有不兼容的地方还是很正常的。</p>
<p>linux环境下的话，可以下载numpy和scipy的源码直接自己编译，不过需要安装MKL，因为本人已经不用linux很久了，所以也没有仔细阅读具体方法，<a href="https://software.intel.com/zh-cn/articles/numpyscipy-with-intel-mkl" target="_blank" rel="external">这里</a>有很清晰的流程说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>最近想使用python做一些机器学习方向的算法实现，使用python做数据分析和矩阵运算什么的常需要三个库文件：numpy、scipy和matplotlib，于是着手安装。<br>我自己机子的配置是win8+64位操作系统，python安装的版本是3.4.1。安装这几个库首先安装numpy，然后是scipy和matplotlib。<br>查询了numpy的官网后发现根本没有64位，3.4版本python的release版本包，可能是python3.4刚更新的缘故，SourceForge的更新比较慢，还没有最新的发布。scipy和matplotlib也相同，也真是痛苦。<br>上网搜了一些解决方案，当时以为比较简单的问题，直接baidu，结果真是失望，搜索出来的都是无关紧要的内容（原谅我没有google…）。<br>终于在stackoverflow里查到了一些方案，其中一个<a href="http://stackoverflow.com/questions/11200137/installing-numpy-on-64bit-windows-7-with-python-2-7-3" target="_blank" rel="external">install numpy on 64bit win7 with python2.7.3</a>，里面提示了一个<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy" target="_blank" rel="external">资源网站</a>，网站里发布了根据<a href="https://software.intel.com/en-us/intel-mkl" target="_blank" rel="external">Intel® Math Kernel Library</a>第三方生成的最新的python库，进去看了一下，里面很多python可使用的编译好的库。<br>由于我自己python版本是3.4.1，于是选择了这几个文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">numpy-MKL-<span class="number">1.9</span>.<span class="number">0</span>.win-amd64-<span class="keyword">py3</span>.<span class="number">4</span>.<span class="keyword">exe</span></div><div class="line">SciPy-<span class="number">0.13</span>.<span class="number">2</span>.win-AMD64-<span class="keyword">py3</span>.<span class="number">4</span>.<span class="keyword">exe</span></div><div class="line">matplotlib-<span class="number">1.4</span>.<span class="number">0</span>.win-amd64-<span class="keyword">py3</span>.<span class="number">4</span>.<span class="keyword">exe</span></div></pre></td></tr></table></figure>

<p>]]>
    
    </summary>
    
      <category term="numpy" scheme="http://goldencui.org/tags/numpy/"/>
    
      <category term="scipy" scheme="http://goldencui.org/tags/scipy/"/>
    
      <category term="matplotlib" scheme="http://goldencui.org/tags/matplotlib/"/>
    
      <category term="python" scheme="http://goldencui.org/tags/python/"/>
    
      <category term="win64" scheme="http://goldencui.org/tags/win64/"/>
    
      <category term="python" scheme="http://goldencui.org/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于FPGA的SOPC系统设计tips]]></title>
    <link href="http://goldencui.org/2014/09/26/%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84SOPC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1tips/"/>
    <id>http://goldencui.org/2014/09/26/基于FPGA的SOPC系统设计tips/</id>
    <published>2014-09-26T09:57:53.000Z</published>
    <updated>2014-10-15T06:54:55.000Z</updated>
    <content type="html"><![CDATA[<p> 之前做了半年的基于FPGA的SOPC的研究，期间遇到很多问题，对于我这个以前只搞过软件的人来说简直是一种折磨，从最简单的串口信息获取，到FPGA外设驱动,这期间遇到很多困难，好在老天有眼一一克服，这篇文章零散的记录基于FPGA嵌入式PPC440微处理器+standalone模式下系统编程方面的操作，以tips为形式展现，只列出系统构建过程中遇到的问题以及解决方法。一些XILINX官网可以查到的技术资料这里暂且不提，后面会附上链接。</p>
<h2 id="1-_浮点数据串口输出">1. 浮点数据串口输出</h2>
<p>XILINX公司提供的标准c一部分实现，并不是所有。它提供的标准串口输出函数包括xil_printf(),printnum();前一个函数和标准c相似，printnum()输出数字型数据。但是自己项目中涉及到浮点型数据的展示，所以想着xil_printf(“%f”,float_data)，发现根本不行，检查了xil_print()的源码，发现根本没有浮点输出的模式（orz…）。<br>仔细检查了XILINX SDK的技术文档，发现它提供了另一个标准函数的实现sprintf()，和print()函数，print()函数就是打印字符类型数据，所以我们可以把浮点类型数据转变为char*字符串，然后输出。所以包装一下，加入了double型和float型数据的打印程序：<br><a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> print_double(<span class="keyword">double</span> f)</div><div class="line">{</div><div class="line">	<span class="keyword">char</span> out[<span class="number">40</span>];</div><div class="line">	<span class="keyword">char</span> *output=out;</div><div class="line">	<span class="built_in">sprintf</span>(output,<span class="string">"%.3f"</span>,f);</div><div class="line">	print(out);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> print_float(<span class="keyword">float</span> f)</div><div class="line">{</div><div class="line">	<span class="keyword">char</span> out[<span class="number">20</span>];</div><div class="line">	<span class="keyword">char</span> *output=out;</div><div class="line">	<span class="built_in">sprintf</span>(output,<span class="string">"%.3f"</span>,f);</div><div class="line">	print(out);</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="2-_Sqrt函数问题">2. Sqrt函数问题</h2>
<p>程序中遇到过一个地方需要sqrt()调用，一般思路是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Double_result=<span class="built_in">sqrt</span>(double_data);</div></pre></td></tr></table></figure>

<p>程序一运行我就哭了，崩溃。。。。仔细测试了很多方法，发现这种模式可行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">u32_result=<span class="built_in">sqrt</span>(u32_data);</div></pre></td></tr></table></figure>

<p>可惜u32类型类似整形，会对小数位截断，这样得不到精确的解，于是尝试改进得到一个可以运行的模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">u32_result=<span class="built_in">sqrt</span>((<span class="keyword">double</span>)u32_data);</div></pre></td></tr></table></figure>

<p>可行，但是还不满意，得到结果还是整形；突然想到我们系统需求是小数点2位精确，这样的话可以采取这样的形式解决：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">u32_data=u32_data*<span class="number">10000</span>;</div><div class="line">u32_result=<span class="built_in">sqrt</span>(u32_data);</div><div class="line">double_result=(<span class="keyword">double</span>)u32_result/<span class="number">100</span>;</div></pre></td></tr></table></figure>

<h2 id="3-_DDR2_读写_">3. DDR2 读写 </h2>
<p>首先在硬件系统结构设计的时候，加入DDR2外设，得到DDR2存储的base_address，然后再standalone模式中加入实现。<br>读：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">u32_DDR2_addr = base_address; (例如：<span class="number">0x00000000</span>)</div><div class="line">u32_word = u32_DDR2_addr[u32_index];</div></pre></td></tr></table></figure>

<p>写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">u32_DDR2_addr[u32_index] = u32_word;</div></pre></td></tr></table></figure>

<h2 id="4-_PPC440_微处理器时间获取">4. PPC440 微处理器时间获取</h2>
<p>在XPS上进行硬件系统设计的采用的PPC440主频是125MHZ。XILINX内并未实现标准操作系统的timer功能，所以查阅了XILINX提供的源码找到一种提供计时的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">u32 ReadTimer()</div><div class="line">{</div><div class="line">	u32 timeCount;</div><div class="line">	timeCount=XTmrCtr_ReadReg(InstancePtr.BaseAddress,</div><div class="line">					 TmrCtrNumber, XTC_TCR_OFFSET);</div><div class="line">	<span class="keyword">return</span> timeCount;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> InitTimer()</div><div class="line">{</div><div class="line">	InstancePtr.BaseAddress=TIMER_ADDR; <span class="comment">//timer addr</span></div><div class="line">	TmrCtrNumber=TIMER_NUM; <span class="comment">// timer number</span></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Reset the timer and the interrupt</div><div class="line">	 */</div><div class="line">	XTmrCtr_WriteReg(InstancePtr.BaseAddress, TmrCtrNumber,</div><div class="line">			  XTC_TCSR_OFFSET,</div><div class="line">			  XTC_CSR_INT_OCCURED_MASK | XTC_CSR_LOAD_MASK);</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Set the control/status register to enable timer</div><div class="line">	 */</div><div class="line">	XTmrCtr_WriteReg(InstancePtr.BaseAddress, TmrCtrNumber,</div><div class="line">			  XTC_TCSR_OFFSET, XTC_CSR_ENABLE_TMR_MASK);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用计时方法的时候首先需要调用一次InitTimer()，然后在计数器开启的状态下可以调用ReadTimer()读计数器寄存器.<br>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">InitTimer(); <span class="comment">// initial  timer	</span></div><div class="line">Todo module</div><div class="line">u32_TimerCount =ReadTimer();</div></pre></td></tr></table></figure>

<p>这里得到的u32_TimerCount是PPC的指令计数，得到精确的描述还需要如下处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">u32 sec_time = u32_TimerCount/<span class="number">125000000</span>; <span class="comment">//(ppc440 主频125MHZ)</span></div></pre></td></tr></table></figure>

<p>资源：<br><a href="http://tgoogle.xilinx.com/search?q=SDK+DVI&amp;btnG=New+Search&amp;getfields=*&amp;numgm=5&amp;filter=0&amp;proxystylesheet=support&amp;client=support&amp;getfields=*&amp;num=200&amp;oe=UTF-8&amp;ie=UTF-8&amp;output=xml_no_dtd&amp;requiredfields=-Archived%3Atrue&amp;show_dynamic_navigation=1&amp;sort=date%3AD%3AL%3Ad1&amp;lang2search=&amp;wc=200&amp;wc_mc=1&amp;ud=1&amp;exclude_apps=1&amp;site=Answers_Docs_Forums" target="_blank" rel="external">xilinx 资源搜索</a><br><a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx12_1/SDK_Doc/tasks/sdk_t_create_new_appln.htm" target="_blank" rel="external">xilnx sdk嵌入式开发 官方指导</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 之前做了半年的基于FPGA的SOPC的研究，期间遇到很多问题，对于我这个以前只搞过软件的人来说简直是一种折磨，从最简单的串口信息获取，到FPGA外设驱动,这期间遇到很多困难，好在老天有眼一一克服，这篇文章零散的记录基于FPGA嵌入式PPC440微处理器+standalone模式下系统编程方面的操作，以tips为形式展现，只列出系统构建过程中遇到的问题以及解决方法。一些XILINX官网可以查到的技术资料这里暂且不提，后面会附上链接。</p>
<h2 id="1-_浮点数据串口输出">1. 浮点数据串口输出</h2>
<p>XILINX公司提供的标准c一部分实现，并不是所有。它提供的标准串口输出函数包括xil_printf(),printnum();前一个函数和标准c相似，printnum()输出数字型数据。但是自己项目中涉及到浮点型数据的展示，所以想着xil_printf(“%f”,float_data)，发现根本不行，检查了xil_print()的源码，发现根本没有浮点输出的模式（orz…）。<br>仔细检查了XILINX SDK的技术文档，发现它提供了另一个标准函数的实现sprintf()，和print()函数，print()函数就是打印字符类型数据，所以我们可以把浮点类型数据转变为char*字符串，然后输出。所以包装一下，加入了double型和float型数据的打印程序：<br>]]>
    
    </summary>
    
      <category term="SOPC" scheme="http://goldencui.org/tags/SOPC/"/>
    
      <category term="XILINX" scheme="http://goldencui.org/tags/XILINX/"/>
    
      <category term="PPC" scheme="http://goldencui.org/tags/PPC/"/>
    
      <category term="嵌入式" scheme="http://goldencui.org/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git基础命令总结]]></title>
    <link href="http://goldencui.org/2014/07/28/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://goldencui.org/2014/07/28/git基础命令总结/</id>
    <published>2014-07-27T16:15:26.000Z</published>
    <updated>2014-10-15T06:52:38.000Z</updated>
    <content type="html"><![CDATA[<h4 id="（针对ssh方式）"><em>（针对ssh方式）</em></h4>
<hr>
<h1 id="1_github_代码提交">1  github 代码提交</h1>
<p><strong>创建新的版本库</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">touch README.md</div><div class="line"><span class="variable">$git</span> init</div><div class="line"><span class="variable">$git</span> add README.md</div><div class="line"><span class="variable">$git</span> commit -<span class="keyword">m</span> <span class="string">"first commit"</span></div><div class="line"><span class="variable">$git</span> remote add origin git<span class="variable">@github</span>.com:youname/youproject.git</div><div class="line"><span class="variable">$git</span> <span class="keyword">push</span> -u origin master</div></pre></td></tr></table></figure>

<p><strong>推送现有的版本库</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$git</span> remote add origin git<span class="variable">@github</span>.com:youname/youproject.git</div><div class="line"><span class="variable">$git</span> <span class="keyword">push</span> -u origin master</div></pre></td></tr></table></figure>

<p><strong>添加修改的版本库</strong><br><a id="more"></a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$git</span> add . <span class="comment">// .表示添加所有文件 </span></div><div class="line"><span class="variable">$git</span> commit -m <span class="string">"修改日志"</span></div><div class="line"><span class="variable">$git</span> push -u origin master</div></pre></td></tr></table></figure>

<p><strong><em>错误解决</em></strong></p>
<hr>
<h4 id="1-运行：">1.运行：</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">git</span> remote add origin git<span class="variable">@github</span>.com:youname/youproject.git</div></pre></td></tr></table></figure>

<p>错误提示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fata<span class="variable">l:</span> remote origin already <span class="built_in">exists</span>.</div></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$git</span> remote rm origin</div></pre></td></tr></table></figure>

<h4 id="2-运行：">2.运行：</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="variable">$ </span>git push origin master</div></pre></td></tr></table></figure>

<p>错误提示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">error</span>:failed <span class="keyword">to</span> push som refs <span class="keyword">to</span></div></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull origin master <span class="comment">// 先把远程服务器中版本拉取下来，再push</span></div></pre></td></tr></table></figure>

<hr>
<h1 id="2_github_代码clone">2  github 代码clone</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>youname/youproject.git  <span class="string">"path"</span> /<span class="regexp">/ path 要存放本地版本库的地址</span></div></pre></td></tr></table></figure>

<p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png" alt="GitHub" title="GitHub cat"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="（针对ssh方式）"><em>（针对ssh方式）</em></h4>
<hr>
<h1 id="1_github_代码提交">1  github 代码提交</h1>
<p><strong>创建新的版本库</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">touch README.md</div><div class="line"><span class="variable">$git</span> init</div><div class="line"><span class="variable">$git</span> add README.md</div><div class="line"><span class="variable">$git</span> commit -<span class="keyword">m</span> <span class="string">"first commit"</span></div><div class="line"><span class="variable">$git</span> remote add origin git<span class="variable">@github</span>.com:youname/youproject.git</div><div class="line"><span class="variable">$git</span> <span class="keyword">push</span> -u origin master</div></pre></td></tr></table></figure>

<p><strong>推送现有的版本库</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$git</span> remote add origin git<span class="variable">@github</span>.com:youname/youproject.git</div><div class="line"><span class="variable">$git</span> <span class="keyword">push</span> -u origin master</div></pre></td></tr></table></figure>

<p><strong>添加修改的版本库</strong><br>]]>
    
    </summary>
    
      <category term="github" scheme="http://goldencui.org/tags/github/"/>
    
      <category term="代码托管" scheme="http://goldencui.org/categories/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(ZZ)休息，休息一会儿]]></title>
    <link href="http://goldencui.org/2014/07/26/%E4%BC%91%E6%81%AF%EF%BC%8C%E4%BC%91%E6%81%AF%E4%B8%80%E4%BC%9A%E5%84%BF/"/>
    <id>http://goldencui.org/2014/07/26/休息，休息一会儿/</id>
    <published>2014-07-26T04:01:39.000Z</published>
    <updated>2014-09-26T11:07:35.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://www.yinwang.org/images/yixiu.jpg" alt="" title="一休哥 1"></p>
<p>本人进入了比较长的，理所应得的休息和娱乐时间。无聊时也看看闲书和电影。这里推荐几个最近看的东西。</p>
<h1 id="《The_Design_of_Everyday_Things》">《The Design of Everyday Things》</h1>
<hr>
<p>最近给我最大影响的是这本1988年出版的《<a href="http://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C" target="_blank" rel="external">The Design of Everyday Things</a>》（简称DOET）。有趣的是，它的作者 Don Norman 曾经是 Apple Fellow，也是《<a href="http://web.mit.edu/~simsong/www/ugh.pdf" target="_blank" rel="external">The Unix-Haters Handbook</a>》一书序言的作者。<br><a id="more"></a><br>DOET 不但包含并且支持了我的博文《<a href="http://www.yinwang.org/blog-cn/2014/04/11/hacker-culture" target="_blank" rel="external">黑客文化的精髓</a>》以及《<a href="http://www.yinwang.org/blog-cn/2014/01/25/pl-and" target="_blank" rel="external">程序语言与……</a>》里的基本观点，而且提出了比《<a href="http://www.yinwang.org/blog-cn/2012/05/18/user-friendliness" target="_blank" rel="external">什么是“对用户友好”</a>》更精辟可行的解决方案。</p>
<p>我觉得这应该是每个程序员必读的书籍。为什么每个程序员必读呢？因为虽然这本书是设计类专业的必读书籍，而计算机及其编程语言和工具，其实才是作者指出的缺乏设计思想的“重灾区”。看了它，你会发现很多所谓的“人为错误”，其实是工具的设计不合理造成的。一个设计良好的工具，应该只需要很少量的文档甚至不需要文档。这本书将提供给你改进一切事物的原则和灵感。你会恢复你的人性。</p>
<p>值得一提的是，虽然 Don Norman 曾经是 Apple Fellow，但我觉得 Apple 产品设计的人性化程度与 Norman 大叔的思维高度还是有一定的差距的。</p>
<p>如果你跟我一样不想用眼睛看书，可以到 Audible 买本<a href="http://www.audible.com/pd/Science-Technology/The-Design-of-Everyday-Things-Audiobook/B005I5MDGQ" target="_blank" rel="external">有声书</a>来听。</p>
<h1 id="《The_Conquest_of_Happiness》">《The Conquest of Happiness》</h1>
<hr>
<p>每个人都想得到快乐，但是他们往往误解了快乐的来源，追求了错误的东西，所以大多数人因此得到的是痛苦，并且给其他人带来痛苦。英国哲学家和数学家罗素写于1930年的《<a href="http://www.amazon.com/The-Conquest-Happiness-Bertrand-Russell/dp/0871401622" target="_blank" rel="external">The Conquest of Happiness</a>》就是彻底的分析这些2014现代人的常见问题的。</p>
<p>在第一部分，罗素透彻的分析了几个常见的不快乐的原因：看破红尘，竞争，过度追求刺激，疲劳，嫉妒，罪恶感，被害妄想症，…… 第二部分，他提出了得到快乐的有效方法。</p>
<p>如果你认为自己没有这些问题，或者认为自己懂得这些是怎么回事，请再次反思一下，因为每个人都或多或少有这些问题。特别是我发现，竞争和攀比所带来的不快乐，在中国人里面是很普遍的现象。</p>
<p>另外，很多心理学家，特别是所谓“正向心理学”（positive psychology），也声称研究如何使人快乐，但我发现他们很多只是扯着“快乐”的幌子，开发自己的市场。罗素的思想比他们深刻很多。</p>
<h1 id="大独裁者">大独裁者</h1>
<hr>
<p>谈到人性，我推荐卓别林在电影《<a href="https://www.youtube.com/watch?v=6FMNFvKEy4c" target="_blank" rel="external">大独裁者</a>》里面的最后演讲。他引起了我对技术的价值的思考。有人说，世界不是毁在疯子手里就是毁在工作狂手里，是有一定的道理的。</p>
<h1 id="摩登时代">摩登时代</h1>
<hr>
<p>其实比《大独裁者》更幽默，更有趣，对现代社会更有意义的，是卓别林的《<a href="http://www.amazon.com/Modern-Times-Charlie-Chaplin/dp/B004DARF6A" target="_blank" rel="external">摩登时代</a>》。这样一部1930年代的黑白无声电影，道出了直到2014年的今天，世界上最大的问题：过度工作。<br>现代社会很多人为了所谓的“生存”，把自己变成了一台盲目不停工作的机器。加班加点的干活，并且还试图让别人也变成跟他一样。一切都是为了工作，为了效率，为了“优秀”，为了出人头地。太多的野心，太多的目标，却对身边最简单的乐趣视而不见。试试放慢匆忙的脚步，思考一下自己在干什么吧！</p>
<p>因为这些原因，我继续睡觉，这是拯救世界的最好办法 zZZZ</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://www.yinwang.org/images/yixiu.jpg" alt="" title="一休哥 1"></p>
<p>本人进入了比较长的，理所应得的休息和娱乐时间。无聊时也看看闲书和电影。这里推荐几个最近看的东西。</p>
<h1 id="《The_Design_of_Everyday_Things》">《The Design of Everyday Things》</h1>
<hr>
<p>最近给我最大影响的是这本1988年出版的《<a href="http://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C" target="_blank" rel="external">The Design of Everyday Things</a>》（简称DOET）。有趣的是，它的作者 Don Norman 曾经是 Apple Fellow，也是《<a href="http://web.mit.edu/~simsong/www/ugh.pdf" target="_blank" rel="external">The Unix-Haters Handbook</a>》一书序言的作者。<br>]]>
    
    </summary>
    
      <category term="hacker" scheme="http://goldencui.org/tags/hacker/"/>
    
      <category term="转载" scheme="http://goldencui.org/categories/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
</feed>
